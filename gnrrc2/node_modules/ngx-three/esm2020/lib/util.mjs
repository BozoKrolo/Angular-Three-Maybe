export function isSettable(obj) {
    return !!(obj && obj.set); // && obj.copy;
}
/**
 * tries to apply the new value to the target.
 * if the new value is 'setter arguments' then it uses set on the target.
 * else it tries to use the 'copy' method of the target if available
 * else it return the newValue as new target
 * if newValue is undefined the old target is returned
 *
 * @param target the target for the new value
 * @param newValue the value to be set
 * @returns the new target(value)
 */
export function applyValue(target, newValue) {
    if (isSettable(target)) {
        if (newValue === undefined) {
            return target;
        }
        if (Array.isArray(newValue)) {
            target.set(...newValue);
            return target;
        }
        if (target.copy && newValue) {
            target.copy(newValue);
            return target;
        }
        // just set the value
        if (newValue !== undefined) {
            target.set(newValue);
            return target;
        }
    }
    else {
        // apply the value
        return newValue;
    }
    // nothing to do
    return target;
}
export function isDisposable(obj) {
    if (obj && typeof obj.dispose === 'function') {
        return true;
    }
    return false;
}
/**
 * compatibility function for checking if a subject is observed
 * works with RxJs 6.x.x and RxJs 7+
 *
 * @param s the subject
 * @returns true if the subject is observed
 */
export function isObserved(s) {
    return (s !== undefined &&
        (s.observed /* <-- needs at least RxJs 7.x.x */ || s.observers?.length > 0) /* <-- for RxJs < 7.x.x */);
}
// This can live anywhere in your codebase:
export function applyMixins(derivedCtor, constructors) {
    constructors.forEach((baseCtor) => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
            Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name) || Object.create(null));
        });
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25neC10aHJlZS9zcmMvbGliL3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBT0EsTUFBTSxVQUFVLFVBQVUsQ0FBQyxHQUFRO0lBQ2pDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLGVBQWU7QUFDNUMsQ0FBQztBQUVEOzs7Ozs7Ozs7O0dBVUc7QUFDSCxNQUFNLFVBQVUsVUFBVSxDQUFJLE1BQVMsRUFBRSxRQUFvQjtJQUMzRCxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUN0QixJQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7WUFDMUIsT0FBTyxNQUFXLENBQUM7U0FDcEI7UUFFRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDM0IsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDO1lBQ3hCLE9BQU8sTUFBVyxDQUFDO1NBQ3BCO1FBRUQsSUFBSSxNQUFNLENBQUMsSUFBSSxJQUFJLFFBQVEsRUFBRTtZQUMzQixNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3RCLE9BQU8sTUFBVyxDQUFDO1NBQ3BCO1FBRUQscUJBQXFCO1FBQ3JCLElBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtZQUMxQixNQUFNLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3JCLE9BQU8sTUFBTSxDQUFDO1NBQ2Y7S0FDRjtTQUFNO1FBQ0wsa0JBQWtCO1FBQ2xCLE9BQU8sUUFBYSxDQUFDO0tBQ3RCO0lBRUQsZ0JBQWdCO0lBQ2hCLE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFFRCxNQUFNLFVBQVUsWUFBWSxDQUFDLEdBQVE7SUFDbkMsSUFBSSxHQUFHLElBQUksT0FBTyxHQUFHLENBQUMsT0FBTyxLQUFLLFVBQVUsRUFBRTtRQUM1QyxPQUFPLElBQUksQ0FBQztLQUNiO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsTUFBTSxVQUFVLFVBQVUsQ0FBVSxDQUFjO0lBQ2hELE9BQU8sQ0FDTCxDQUFDLEtBQUssU0FBUztRQUNmLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxtQ0FBbUMsSUFBSSxDQUFDLENBQUMsU0FBUyxFQUFFLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQywwQkFBMEIsQ0FDdkcsQ0FBQztBQUNKLENBQUM7QUFFRCwyQ0FBMkM7QUFDM0MsTUFBTSxVQUFVLFdBQVcsQ0FBQyxXQUFnQixFQUFFLFlBQW1CO0lBQy9ELFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRTtRQUNoQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQzlELE1BQU0sQ0FBQyxjQUFjLENBQ25CLFdBQVcsQ0FBQyxTQUFTLEVBQ3JCLElBQUksRUFDSixNQUFNLENBQUMsd0JBQXdCLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUNqRixDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGhTZXR0YWJsZSB7XG4gIHNldCguLi5hcmdzOiBhbnkpOiB0aGlzO1xuICBjb3B5Pyh2YWx1ZTogYW55KTogdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2V0dGFibGUob2JqOiBhbnkpOiBvYmogaXMgVGhTZXR0YWJsZSB7XG4gIHJldHVybiAhIShvYmogJiYgb2JqLnNldCk7IC8vICYmIG9iai5jb3B5O1xufVxuXG4vKipcbiAqIHRyaWVzIHRvIGFwcGx5IHRoZSBuZXcgdmFsdWUgdG8gdGhlIHRhcmdldC5cbiAqIGlmIHRoZSBuZXcgdmFsdWUgaXMgJ3NldHRlciBhcmd1bWVudHMnIHRoZW4gaXQgdXNlcyBzZXQgb24gdGhlIHRhcmdldC5cbiAqIGVsc2UgaXQgdHJpZXMgdG8gdXNlIHRoZSAnY29weScgbWV0aG9kIG9mIHRoZSB0YXJnZXQgaWYgYXZhaWxhYmxlXG4gKiBlbHNlIGl0IHJldHVybiB0aGUgbmV3VmFsdWUgYXMgbmV3IHRhcmdldFxuICogaWYgbmV3VmFsdWUgaXMgdW5kZWZpbmVkIHRoZSBvbGQgdGFyZ2V0IGlzIHJldHVybmVkXG4gKlxuICogQHBhcmFtIHRhcmdldCB0aGUgdGFyZ2V0IGZvciB0aGUgbmV3IHZhbHVlXG4gKiBAcGFyYW0gbmV3VmFsdWUgdGhlIHZhbHVlIHRvIGJlIHNldFxuICogQHJldHVybnMgdGhlIG5ldyB0YXJnZXQodmFsdWUpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVZhbHVlPFQ+KHRhcmdldDogVCwgbmV3VmFsdWU/OiBhbnlbXSB8IFQpOiBUIHtcbiAgaWYgKGlzU2V0dGFibGUodGFyZ2V0KSkge1xuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0IGFzIFQ7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV3VmFsdWUpKSB7XG4gICAgICB0YXJnZXQuc2V0KC4uLm5ld1ZhbHVlKTtcbiAgICAgIHJldHVybiB0YXJnZXQgYXMgVDtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0LmNvcHkgJiYgbmV3VmFsdWUpIHtcbiAgICAgIHRhcmdldC5jb3B5KG5ld1ZhbHVlKTtcbiAgICAgIHJldHVybiB0YXJnZXQgYXMgVDtcbiAgICB9XG5cbiAgICAvLyBqdXN0IHNldCB0aGUgdmFsdWVcbiAgICBpZiAobmV3VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LnNldChuZXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBhcHBseSB0aGUgdmFsdWVcbiAgICByZXR1cm4gbmV3VmFsdWUgYXMgVDtcbiAgfVxuXG4gIC8vIG5vdGhpbmcgdG8gZG9cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGlzcG9zYWJsZShvYmo6IGFueSk6IG9iaiBpcyB7IGRpc3Bvc2U6ICgpID0+IHZvaWQgfSB7XG4gIGlmIChvYmogJiYgdHlwZW9mIG9iai5kaXNwb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIGNvbXBhdGliaWxpdHkgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEgc3ViamVjdCBpcyBvYnNlcnZlZFxuICogd29ya3Mgd2l0aCBSeEpzIDYueC54IGFuZCBSeEpzIDcrXG4gKlxuICogQHBhcmFtIHMgdGhlIHN1YmplY3RcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHN1YmplY3QgaXMgb2JzZXJ2ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JzZXJ2ZWQ8VCA9IGFueT4ocz86IFN1YmplY3Q8VD4pOiBzIGlzIFN1YmplY3Q8VD4ge1xuICByZXR1cm4gKFxuICAgIHMgIT09IHVuZGVmaW5lZCAmJlxuICAgIChzLm9ic2VydmVkIC8qIDwtLSBuZWVkcyBhdCBsZWFzdCBSeEpzIDcueC54ICovIHx8IHMub2JzZXJ2ZXJzPy5sZW5ndGggPiAwKSAvKiA8LS0gZm9yIFJ4SnMgPCA3LngueCAqL1xuICApO1xufVxuXG4vLyBUaGlzIGNhbiBsaXZlIGFueXdoZXJlIGluIHlvdXIgY29kZWJhc2U6XG5leHBvcnQgZnVuY3Rpb24gYXBwbHlNaXhpbnMoZGVyaXZlZEN0b3I6IGFueSwgY29uc3RydWN0b3JzOiBhbnlbXSkge1xuICBjb25zdHJ1Y3RvcnMuZm9yRWFjaCgoYmFzZUN0b3IpID0+IHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiYXNlQ3Rvci5wcm90b3R5cGUpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgZGVyaXZlZEN0b3IucHJvdG90eXBlLFxuICAgICAgICBuYW1lLFxuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2VDdG9yLnByb3RvdHlwZSwgbmFtZSkgfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIHR5cGVkIGNoYW5nZXMgZm9yIG5nT25DaGFuZ2VzXG5cbnR5cGUgTWFya0Z1bmN0aW9uUHJvcGVydGllczxDb21wb25lbnQ+ID0ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICBbS2V5IGluIGtleW9mIENvbXBvbmVudF06IENvbXBvbmVudFtLZXldIGV4dGVuZHMgRnVuY3Rpb24gPyBuZXZlciA6IEtleTtcbn07XG5cbnR5cGUgRXhjbHVkZUZ1bmN0aW9uUHJvcGVydHlOYW1lczxUPiA9IE1hcmtGdW5jdGlvblByb3BlcnRpZXM8VD5ba2V5b2YgVF07XG5cbnR5cGUgRXhjbHVkZUZ1bmN0aW9uczxUPiA9IFBpY2s8VCwgRXhjbHVkZUZ1bmN0aW9uUHJvcGVydHlOYW1lczxUPj47XG5cbmV4cG9ydCB0eXBlIE5nQ2hhbmdlczxDb21wb25lbnQsIFByb3BzID0gRXhjbHVkZUZ1bmN0aW9uczxDb21wb25lbnQ+PiA9IHtcbiAgW0tleSBpbiBrZXlvZiBQcm9wc10/OiB7XG4gICAgcHJldmlvdXNWYWx1ZTogUHJvcHNbS2V5XTtcbiAgICBjdXJyZW50VmFsdWU6IFByb3BzW0tleV07XG4gICAgZmlyc3RDaGFuZ2U6IGJvb2xlYW47XG4gICAgaXNGaXJzdENoYW5nZSgpOiBib29sZWFuO1xuICB9O1xufTtcbiJdfQ==