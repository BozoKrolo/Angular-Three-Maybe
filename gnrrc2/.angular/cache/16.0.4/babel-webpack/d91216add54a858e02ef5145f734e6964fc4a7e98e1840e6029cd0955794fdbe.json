{"ast":null,"code":"import { CompressedTextureLoader, RGBAFormat, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_S3TC_DXT1_Format } from 'three';\nclass DDSLoader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager);\n  }\n  parse(buffer, loadMipmaps) {\n    const dds = {\n      mipmaps: [],\n      width: 0,\n      height: 0,\n      format: null,\n      mipmapCount: 1\n    };\n\n    // Adapted from @toji's DDS utils\n    // https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n    // All values and structures referenced from:\n    // http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n    const DDS_MAGIC = 0x20534444;\n\n    // const DDSD_CAPS = 0x1;\n    // const DDSD_HEIGHT = 0x2;\n    // const DDSD_WIDTH = 0x4;\n    // const DDSD_PITCH = 0x8;\n    // const DDSD_PIXELFORMAT = 0x1000;\n    const DDSD_MIPMAPCOUNT = 0x20000;\n    // const DDSD_LINEARSIZE = 0x80000;\n    // const DDSD_DEPTH = 0x800000;\n\n    // const DDSCAPS_COMPLEX = 0x8;\n    // const DDSCAPS_MIPMAP = 0x400000;\n    // const DDSCAPS_TEXTURE = 0x1000;\n\n    const DDSCAPS2_CUBEMAP = 0x200;\n    const DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;\n    const DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;\n    const DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;\n    const DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;\n    const DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;\n    const DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;\n    // const DDSCAPS2_VOLUME = 0x200000;\n\n    // const DDPF_ALPHAPIXELS = 0x1;\n    // const DDPF_ALPHA = 0x2;\n    // const DDPF_FOURCC = 0x4;\n    // const DDPF_RGB = 0x40;\n    // const DDPF_YUV = 0x200;\n    // const DDPF_LUMINANCE = 0x20000;\n\n    function fourCCToInt32(value) {\n      return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n    }\n    function int32ToFourCC(value) {\n      return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);\n    }\n    function loadARGBMip(buffer, dataOffset, width, height) {\n      const dataLength = width * height * 4;\n      const srcBuffer = new Uint8Array(buffer, dataOffset, dataLength);\n      const byteArray = new Uint8Array(dataLength);\n      let dst = 0;\n      let src = 0;\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const b = srcBuffer[src];\n          src++;\n          const g = srcBuffer[src];\n          src++;\n          const r = srcBuffer[src];\n          src++;\n          const a = srcBuffer[src];\n          src++;\n          byteArray[dst] = r;\n          dst++; //r\n          byteArray[dst] = g;\n          dst++; //g\n          byteArray[dst] = b;\n          dst++; //b\n          byteArray[dst] = a;\n          dst++; //a\n        }\n      }\n\n      return byteArray;\n    }\n    const FOURCC_DXT1 = fourCCToInt32('DXT1');\n    const FOURCC_DXT3 = fourCCToInt32('DXT3');\n    const FOURCC_DXT5 = fourCCToInt32('DXT5');\n    const FOURCC_ETC1 = fourCCToInt32('ETC1');\n    const headerLengthInt = 31; // The header length in 32 bit ints\n\n    // Offsets into the header array\n\n    const off_magic = 0;\n    const off_size = 1;\n    const off_flags = 2;\n    const off_height = 3;\n    const off_width = 4;\n    const off_mipmapCount = 7;\n\n    // const off_pfFlags = 20;\n    const off_pfFourCC = 21;\n    const off_RGBBitCount = 22;\n    const off_RBitMask = 23;\n    const off_GBitMask = 24;\n    const off_BBitMask = 25;\n    const off_ABitMask = 26;\n\n    // const off_caps = 27;\n    const off_caps2 = 28;\n    // const off_caps3 = 29;\n    // const off_caps4 = 30;\n\n    // Parse header\n\n    const header = new Int32Array(buffer, 0, headerLengthInt);\n    if (header[off_magic] !== DDS_MAGIC) {\n      console.error('THREE.DDSLoader.parse: Invalid magic number in DDS header.');\n      return dds;\n    }\n    let blockBytes;\n    const fourCC = header[off_pfFourCC];\n    let isRGBAUncompressed = false;\n    switch (fourCC) {\n      case FOURCC_DXT1:\n        blockBytes = 8;\n        dds.format = RGB_S3TC_DXT1_Format;\n        break;\n      case FOURCC_DXT3:\n        blockBytes = 16;\n        dds.format = RGBA_S3TC_DXT3_Format;\n        break;\n      case FOURCC_DXT5:\n        blockBytes = 16;\n        dds.format = RGBA_S3TC_DXT5_Format;\n        break;\n      case FOURCC_ETC1:\n        blockBytes = 8;\n        dds.format = RGB_ETC1_Format;\n        break;\n      default:\n        if (header[off_RGBBitCount] === 32 && header[off_RBitMask] & 0xff0000 && header[off_GBitMask] & 0xff00 && header[off_BBitMask] & 0xff && header[off_ABitMask] & 0xff000000) {\n          isRGBAUncompressed = true;\n          blockBytes = 64;\n          dds.format = RGBAFormat;\n        } else {\n          console.error('THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC(fourCC));\n          return dds;\n        }\n    }\n    dds.mipmapCount = 1;\n    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n      dds.mipmapCount = Math.max(1, header[off_mipmapCount]);\n    }\n    const caps2 = header[off_caps2];\n    dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n    if (dds.isCubemap && (!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ))) {\n      console.error('THREE.DDSLoader.parse: Incomplete cubemap faces');\n      return dds;\n    }\n    dds.width = header[off_width];\n    dds.height = header[off_height];\n    let dataOffset = header[off_size] + 4;\n\n    // Extract mipmaps buffers\n\n    const faces = dds.isCubemap ? 6 : 1;\n    for (let face = 0; face < faces; face++) {\n      let width = dds.width;\n      let height = dds.height;\n      for (let i = 0; i < dds.mipmapCount; i++) {\n        let byteArray, dataLength;\n        if (isRGBAUncompressed) {\n          byteArray = loadARGBMip(buffer, dataOffset, width, height);\n          dataLength = byteArray.length;\n        } else {\n          dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n          byteArray = new Uint8Array(buffer, dataOffset, dataLength);\n        }\n        const mipmap = {\n          'data': byteArray,\n          'width': width,\n          'height': height\n        };\n        dds.mipmaps.push(mipmap);\n        dataOffset += dataLength;\n        width = Math.max(width >> 1, 1);\n        height = Math.max(height >> 1, 1);\n      }\n    }\n    return dds;\n  }\n}\nexport { DDSLoader };","map":{"version":3,"names":["CompressedTextureLoader","RGBAFormat","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_ETC1_Format","RGB_S3TC_DXT1_Format","DDSLoader","constructor","manager","parse","buffer","loadMipmaps","dds","mipmaps","width","height","format","mipmapCount","DDS_MAGIC","DDSD_MIPMAPCOUNT","DDSCAPS2_CUBEMAP","DDSCAPS2_CUBEMAP_POSITIVEX","DDSCAPS2_CUBEMAP_NEGATIVEX","DDSCAPS2_CUBEMAP_POSITIVEY","DDSCAPS2_CUBEMAP_NEGATIVEY","DDSCAPS2_CUBEMAP_POSITIVEZ","DDSCAPS2_CUBEMAP_NEGATIVEZ","fourCCToInt32","value","charCodeAt","int32ToFourCC","String","fromCharCode","loadARGBMip","dataOffset","dataLength","srcBuffer","Uint8Array","byteArray","dst","src","y","x","b","g","r","a","FOURCC_DXT1","FOURCC_DXT3","FOURCC_DXT5","FOURCC_ETC1","headerLengthInt","off_magic","off_size","off_flags","off_height","off_width","off_mipmapCount","off_pfFourCC","off_RGBBitCount","off_RBitMask","off_GBitMask","off_BBitMask","off_ABitMask","off_caps2","header","Int32Array","console","error","blockBytes","fourCC","isRGBAUncompressed","Math","max","caps2","isCubemap","faces","face","i","length","mipmap","push"],"sources":["C:/Users/bozok/Desktop/AngularProject/gnrrc2/node_modules/three/examples/jsm/loaders/DDSLoader.js"],"sourcesContent":["import {\n\tCompressedTextureLoader,\n\tRGBAFormat,\n\tRGBA_S3TC_DXT3_Format,\n\tRGBA_S3TC_DXT5_Format,\n\tRGB_ETC1_Format,\n\tRGB_S3TC_DXT1_Format\n} from 'three';\n\nclass DDSLoader extends CompressedTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tparse( buffer, loadMipmaps ) {\n\n\t\tconst dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\n\n\t\t// Adapted from @toji's DDS utils\n\t\t// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n\t\t// All values and structures referenced from:\n\t\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n\t\tconst DDS_MAGIC = 0x20534444;\n\n\t\t// const DDSD_CAPS = 0x1;\n\t\t// const DDSD_HEIGHT = 0x2;\n\t\t// const DDSD_WIDTH = 0x4;\n\t\t// const DDSD_PITCH = 0x8;\n\t\t// const DDSD_PIXELFORMAT = 0x1000;\n\t\tconst DDSD_MIPMAPCOUNT = 0x20000;\n\t\t// const DDSD_LINEARSIZE = 0x80000;\n\t\t// const DDSD_DEPTH = 0x800000;\n\n\t\t// const DDSCAPS_COMPLEX = 0x8;\n\t\t// const DDSCAPS_MIPMAP = 0x400000;\n\t\t// const DDSCAPS_TEXTURE = 0x1000;\n\n\t\tconst DDSCAPS2_CUBEMAP = 0x200;\n\t\tconst DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;\n\t\tconst DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;\n\t\tconst DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;\n\t\tconst DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;\n\t\tconst DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;\n\t\tconst DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;\n\t\t// const DDSCAPS2_VOLUME = 0x200000;\n\n\t\t// const DDPF_ALPHAPIXELS = 0x1;\n\t\t// const DDPF_ALPHA = 0x2;\n\t\t// const DDPF_FOURCC = 0x4;\n\t\t// const DDPF_RGB = 0x40;\n\t\t// const DDPF_YUV = 0x200;\n\t\t// const DDPF_LUMINANCE = 0x20000;\n\n\t\tfunction fourCCToInt32( value ) {\n\n\t\t\treturn value.charCodeAt( 0 ) +\n\t\t\t\t( value.charCodeAt( 1 ) << 8 ) +\n\t\t\t\t( value.charCodeAt( 2 ) << 16 ) +\n\t\t\t\t( value.charCodeAt( 3 ) << 24 );\n\n\t\t}\n\n\t\tfunction int32ToFourCC( value ) {\n\n\t\t\treturn String.fromCharCode(\n\t\t\t\tvalue & 0xff,\n\t\t\t\t( value >> 8 ) & 0xff,\n\t\t\t\t( value >> 16 ) & 0xff,\n\t\t\t\t( value >> 24 ) & 0xff\n\t\t\t);\n\n\t\t}\n\n\t\tfunction loadARGBMip( buffer, dataOffset, width, height ) {\n\n\t\t\tconst dataLength = width * height * 4;\n\t\t\tconst srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );\n\t\t\tconst byteArray = new Uint8Array( dataLength );\n\t\t\tlet dst = 0;\n\t\t\tlet src = 0;\n\t\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\t\tconst b = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst g = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst r = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst a = srcBuffer[ src ]; src ++;\n\t\t\t\t\tbyteArray[ dst ] = r; dst ++;\t//r\n\t\t\t\t\tbyteArray[ dst ] = g; dst ++;\t//g\n\t\t\t\t\tbyteArray[ dst ] = b; dst ++;\t//b\n\t\t\t\t\tbyteArray[ dst ] = a; dst ++;\t//a\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn byteArray;\n\n\t\t}\n\n\t\tconst FOURCC_DXT1 = fourCCToInt32( 'DXT1' );\n\t\tconst FOURCC_DXT3 = fourCCToInt32( 'DXT3' );\n\t\tconst FOURCC_DXT5 = fourCCToInt32( 'DXT5' );\n\t\tconst FOURCC_ETC1 = fourCCToInt32( 'ETC1' );\n\n\t\tconst headerLengthInt = 31; // The header length in 32 bit ints\n\n\t\t// Offsets into the header array\n\n\t\tconst off_magic = 0;\n\n\t\tconst off_size = 1;\n\t\tconst off_flags = 2;\n\t\tconst off_height = 3;\n\t\tconst off_width = 4;\n\n\t\tconst off_mipmapCount = 7;\n\n\t\t// const off_pfFlags = 20;\n\t\tconst off_pfFourCC = 21;\n\t\tconst off_RGBBitCount = 22;\n\t\tconst off_RBitMask = 23;\n\t\tconst off_GBitMask = 24;\n\t\tconst off_BBitMask = 25;\n\t\tconst off_ABitMask = 26;\n\n\t\t// const off_caps = 27;\n\t\tconst off_caps2 = 28;\n\t\t// const off_caps3 = 29;\n\t\t// const off_caps4 = 30;\n\n\t\t// Parse header\n\n\t\tconst header = new Int32Array( buffer, 0, headerLengthInt );\n\n\t\tif ( header[ off_magic ] !== DDS_MAGIC ) {\n\n\t\t\tconsole.error( 'THREE.DDSLoader.parse: Invalid magic number in DDS header.' );\n\t\t\treturn dds;\n\n\t\t}\n\n\t\tlet blockBytes;\n\n\t\tconst fourCC = header[ off_pfFourCC ];\n\n\t\tlet isRGBAUncompressed = false;\n\n\t\tswitch ( fourCC ) {\n\n\t\t\tcase FOURCC_DXT1:\n\n\t\t\t\tblockBytes = 8;\n\t\t\t\tdds.format = RGB_S3TC_DXT1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DXT3:\n\n\t\t\t\tblockBytes = 16;\n\t\t\t\tdds.format = RGBA_S3TC_DXT3_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DXT5:\n\n\t\t\t\tblockBytes = 16;\n\t\t\t\tdds.format = RGBA_S3TC_DXT5_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_ETC1:\n\n\t\t\t\tblockBytes = 8;\n\t\t\t\tdds.format = RGB_ETC1_Format;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tif ( header[ off_RGBBitCount ] === 32\n\t\t\t\t\t&& header[ off_RBitMask ] & 0xff0000\n\t\t\t\t\t&& header[ off_GBitMask ] & 0xff00\n\t\t\t\t\t&& header[ off_BBitMask ] & 0xff\n\t\t\t\t\t&& header[ off_ABitMask ] & 0xff000000 ) {\n\n\t\t\t\t\tisRGBAUncompressed = true;\n\t\t\t\t\tblockBytes = 64;\n\t\t\t\t\tdds.format = RGBAFormat;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) );\n\t\t\t\t\treturn dds;\n\n\t\t\t\t}\n\n\t\t}\n\n\t\tdds.mipmapCount = 1;\n\n\t\tif ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\n\n\t\t\tdds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\n\n\t\t}\n\n\t\tconst caps2 = header[ off_caps2 ];\n\t\tdds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n\t\tif ( dds.isCubemap && (\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ )\n\t\t) ) {\n\n\t\t\tconsole.error( 'THREE.DDSLoader.parse: Incomplete cubemap faces' );\n\t\t\treturn dds;\n\n\t\t}\n\n\t\tdds.width = header[ off_width ];\n\t\tdds.height = header[ off_height ];\n\n\t\tlet dataOffset = header[ off_size ] + 4;\n\n\t\t// Extract mipmaps buffers\n\n\t\tconst faces = dds.isCubemap ? 6 : 1;\n\n\t\tfor ( let face = 0; face < faces; face ++ ) {\n\n\t\t\tlet width = dds.width;\n\t\t\tlet height = dds.height;\n\n\t\t\tfor ( let i = 0; i < dds.mipmapCount; i ++ ) {\n\n\t\t\t\tlet byteArray, dataLength;\n\n\t\t\t\tif ( isRGBAUncompressed ) {\n\n\t\t\t\t\tbyteArray = loadARGBMip( buffer, dataOffset, width, height );\n\t\t\t\t\tdataLength = byteArray.length;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\n\t\t\t\t\tbyteArray = new Uint8Array( buffer, dataOffset, dataLength );\n\n\t\t\t\t}\n\n\t\t\t\tconst mipmap = { 'data': byteArray, 'width': width, 'height': height };\n\t\t\t\tdds.mipmaps.push( mipmap );\n\n\t\t\t\tdataOffset += dataLength;\n\n\t\t\t\twidth = Math.max( width >> 1, 1 );\n\t\t\t\theight = Math.max( height >> 1, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn dds;\n\n\t}\n\n}\n\nexport { DDSLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}